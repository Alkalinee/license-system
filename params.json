{"name":"License-system","tagline":"Ein Lizenzsystem mit RSA-Signaturen","body":"# Lizenzsystem mit RSA-Signaturen\r\nAufgrund der Nachfrage habe ich mich mal dazu durchgerungen, einen kleinen Beitrag dazu zu verfassen.\r\n\r\n## Voraussetzungen\r\nUm die Schritte in diesem Beitrag nachvollziehen zu können, solltest Du grundlegende Kenntnisse zu Public-Private-Key-Kryptografie haben. Hier geht es speziell um das Signieren von Daten.\r\nAußerdem solltest Du die grundlegenden Konzepte von C# (bzw. .NET) beherrschen. Ich zeige es hier mit PHP als Server-Backend, weshalb es auch nicht übel wäre, wenn Du PHP-Code zumindest lesen könntest.\r\n#### Software\r\nSoftwareseitig benötigst Du zum Nachvollziehen des kompletten Beitrags:\r\n\r\n- Visual Studio oder eine andere Möglichkeit, C#-Code zu kompilieren\r\n- Einen Web-Server mit PHP >= 5.4\r\n- Einen Editor für PHP-Dateien\r\n- OpenSSL oder eine andere Möglichkeit, RSA-Schlüsselpaare zu erzeugen (z. B. via .NET und ToXmlString(), siehe unten)\r\n\r\nIch verwende in diesem Beitrag auf der Client-Seite nur .NET-Boardmittel. Wenn Du eine externe Crypto-Library (z. B. BouncyCastle) verwenden möchtest, kannst du das natürlich auch gerne tun.\r\n\r\n\r\n## Verbesser mich!\r\nDer ganze Beitrag inklusive Quelltext befindet sich auf GitHub und kann dort von Jedem verbessert werden:\r\n[nikeee/license-system](https://github.com/nikeee/license-system)\r\nFalls Dir etwas auffällt oder du ein anderes Anliegen hast, kannst Du mir gerne eine Issue hinterlassen oder mich kontaktieren.\r\n\r\n## Was ist das Ziel?\r\nZiel ist es, einen Namen und zusätzliche, beliebige Daten mit einer Signatur zu versehen, sodass auf dieser Grundlage ein Lizenzsystem implementiert werden kann. Bei diesem Lizenzsystem gibt es einen Client und einen Server. Die Aufgabe des Servers ist es, Lizenzschlüssel auszustellen, die am Client mittels RSA-Signatur validiert werden können. So kann der Client die Lizenz auf Gültigkeit prüfen, ohne den Server zu kontaktieren.\r\n\r\n## Okay, dann mal los!\r\nDie Vorgehensweise bei der Methode, wie ich sie hier zeige, lässt sich in folgende Schritte unterteilen:\r\n\r\n1. Einlesen der Lizenz\r\n    1. Auftrennung der Lizenz in einzelne Datenparameter (Name, Typ, Signatur)\r\n2. Standardisierung der übergebenen Daten in einheitliches Format\r\n3. Validierung der Daten mittels überprüfung der RSA-Signatur\r\n\r\n### Aufbau der Lizenz\r\nEine Lizenz ist wie folgt aufgebaut:\r\n```\r\n----------BEGIN LICENSE----------\r\n<Vorname> <Nachname>\r\n<Lizenztyp>\r\n<Signatur>\r\n-----------END LICENSE-----------\r\n```\r\n\r\n- `<Vorname> <Nachname>`: stehen für den Lizenznehmer. Das kann auch eine E-Mail-Adresse oder irgendein beliebiger String sein. Ich verwende hier Vor- und Nachname.\r\n- `<Lizenztyp>`: Um noch zu zeigen, dass man im Prinzip alles in so eine Lizenz stecken kann, habe ich dieses Feld hinzugefügt. Es steht für die Art, um die es sich bei der Lizenz handelt. Z. B. `\"Free\"`, `\"Trial\"` oder `\"Pro\"`. Ich habe hier `SingleUser`, `Commercial` und `OpenSource` verwendet.\r\n- `<Signatur>`: Im Prinzip würde es ausreichen, die ersten beiden Parameter zu lesen und zu wissen, um was für eine Lizenz es sich bei was für einem Lizenznehmer handelt. Leider ist sie dann nicht geschützt vor Manipulation. Aus diesem Grund benötigt man etwas, um die anderen Daten der Lizenz zu validieren. Hierfür wird diese RSA-SHA1-Signatur verwendet. Du musst natürlich nicht RSA nehmen.\r\n\r\nLass' Deiner Kreativität oder Ansprüchen freien Lauf! Es wäre z. B. noch möglich, ein Ablaufdatum oder eine E-Mail-Adresse hinzuzufügen. Der Einfachheit halber habe ich mich aber auf 2 Eigenschaften beschränkt.\r\nWie Du die Lizenzdaten letztendlich aufbaust, ist Dir überlassen. Man könnte hierbei auch mit XML oder JSON arbeiten, um die Verarbeitung etwas zu vereinfachen.\r\n\r\nEine Lizenz sieht dann z. B. so aus:\r\n```\r\n----------BEGIN LICENSE----------\r\nErika Mustermann\r\n2\r\nDEADBEEFCAFEBABEC001D00DEBEEFEA7E5\r\nDEADBEEFCAFEBABEC001D00DEBEEFEA7E5\r\nDEADBEEFCAFEBABEC001D00DEBEEFEA7E5\r\nDEADBEEFCAFEBABEC001D00DEBEEFEA7E5\r\nDEADBEEFCAFEBABEC001D00DEBEEFEA7E5\r\n-----------END LICENSE-----------\r\n```\r\n(Die Signaturdaten sind nicht gültig)\r\n\r\n### 0. Die Lizenz-Klasse\r\nUm den Lizenzkram besser vom restlichen Code der Anwendung zu trennen, legen wir eine Klasse für eine Lizenz an. Diese sieht bei mir jetzt so aus:\r\n\r\n```C#\r\nclass License\r\n{\r\n    private const string _publicKey = \"\"; // TODO\r\n\r\n    private readonly bool _isValid;\r\n    public bool IsValid { get { return _isValid; } }\r\n\r\n    private readonly string _licensee;\r\n    public string Licensee { get { return _licensee; } }\r\n\r\n    private readonly LicenseType _type;\r\n    public LicenseType Type { get { return _type; } }\r\n\r\n    protected License(string licensee, LicenseType type, byte[] verificationData)\r\n    {\r\n        if (string.IsNullOrEmpty(licensee))\r\n            throw new ArgumentNullException(\"licensee\");\r\n        if (verificationData == null)\r\n            throw new ArgumentNullException(\"verificationData\");\r\n\r\n        _licensee = licensee;\r\n        _type = type;\r\n        _isValid = ValidateLicense(verificationData);\r\n    }\r\n\r\n    private bool ValidateLicense(byte[] signature) { /* TODO */ }\r\n\r\n    public static License Parse(string licenseData) { /* TODO */ }\r\n\r\n    private static string GeneralizeDataString(string someString) { /* TODO */ }\r\n}\r\n```\r\n\r\nAußerdem habe ich noch 3 verschiedene Lizenztypen gewählt, um zu zeigen, dass man noch weitere Daten in die Lizenz packen kann:\r\n```C#\r\nenum LicenseType\r\n{\r\n    SingleUser = 1,\r\n    Commercial,\r\n    OpenSource\r\n}\r\n```\r\n\r\nDie Stellen, die mit \"TODO\" gekennzeichnet sind, werden wir in den nächsten Schritten behandeln.\r\n\r\n#### 0.5 Verwendung der Lizenz-Klasse\r\nDie Lizenzklasse kann am Ende so verwendet werden:\r\n```C#\r\nvar license = License.Parse(\"----BEGIN LICENSE-----...\");\r\nif(license.IsValid)\r\n{\r\n    Console.WriteLine(\"Gültige Lizenz!\");\r\n    Console.WriteLine(\"Lizenztyp: \" + license.Type);\r\n}\r\nelse\r\n{\r\n    Console.WriteLine(\"Ungültige Lizenz!\");\r\n}\r\n```\r\n\r\nDer Konstruktor ist `protected`. Ich habe das in diesem Fall so gewählt, da ich möchte, dass man eine Instanz von License nur mit der Parse-Methode erstellen kann. Natürlich könnte man den Konstruktor auch `public` machen.\r\n\r\n### 1. Einlesen der Lizenz\r\nDieser Teil hat eigentlich noch nichts mit Kryptografie zu tun. Es geht nur um das einfache Einlesen der Daten aus dem Lizenzstring, um diese dann an den Konstruktor der License-Klasse zu übergeben.\r\nDer Parse-Teil sieht bei mir so aus:\r\n\r\n```C#\r\npublic static License Parse(string licenseData)\r\n{\r\n    // Pattern, um an die Daten zwischen BEGIN und END zu kommen\r\n    const string pattern = \"^\\\\s*-+BEGIN LICENSE-+(?<data>(\\\\s|.)*?)-+END LICENSE-+\\\\s*$\";\r\n\r\n    var match = Regex.Match(licenseData, pattern, RegexOptions.IgnoreCase); // string auf Muster prüfen\r\n    if (!match.Success) // Wenn das Muster nicht gematched wurde, ist der Lizenz-String nicht lesbar und somit ungültig.\r\n        throw new FormatException();\r\n\r\n    var rawStringData = match.Groups[\"data\"].Value;\r\n    if (string.IsNullOrWhiteSpace(rawStringData)) // Wenn die Daten zwischen BEGIN und END leer bzw nur WhiteSpace sind -> ungültig\r\n        throw new FormatException();\r\n    rawStringData = rawStringData.Trim(); // sonstiges whitespace trimmen (links udn rechts)\r\n\r\n    var splitData = rawStringData.Split('\\n'); // Splitten beim Zeilenumbruch\r\n    if (splitData.Length < 3) // Wenn es weniger als 3 Zeilen (Name, Typ, Signatur) waren -> ungültig\r\n        throw new FormatException();\r\n\r\n    // Ab hier findet auch Schirtt 1.1 statt:\r\n    // 1.1. Auftrennung der Lizenz in einzelne Datenparameter (Name, Typ, Signatur)\r\n\r\n    var licenseeRaw = splitData[0].Trim(); // Name des Lizenznehmers in 1. Zeile\r\n    var licenseTypeRaw = splitData[1].Trim(); // Integer-Wert des Enum-Members von LicenseType in 2. Zeile\r\n\r\n    var type = (LicenseType)int.Parse(licenseTypeRaw); // Integer-Wert in LicenseType umwandeln\r\n\r\n    if (type != LicenseType.SingleUser\r\n        && type != LicenseType.Commercial\r\n        && type != LicenseType.OpenSource)\r\n    {\r\n        // Enums könenn auch Werte annehmen, die nicht im Enum definiert sind, z. B. durch einen Cast.\r\n        // Falls dies bei LicenseType der Fall ist -> ungültig\r\n        throw new FormatException();\r\n    }\r\n\r\n    // Die Signatur besteht aus allen verbleibenden Zeilen\r\n    var verificationDataRaw = string.Join(string.Empty, splitData.Skip(2)).Trim();\r\n\r\n    // Dekodierung des Strings zu Binärdaten (byte[]).\r\n    var verificationData = DecodeDataFromString(verificationDataRaw);\r\n\r\n    // Bis hier hin konnte alles erfolgreich eingelesen werden\r\n    // Ob die Daten aber gültig (== Signatur ist korrekt) sind, wird später überprüft.\r\n\r\n    return new License(licenseeRaw, type, verificationData); // Rückgabe des Lizenz-Objektes mit den eingelesenen Daten\r\n}\r\n\r\n\r\n// Zum Dekodieren der Signaturdaten wird diese Funkton verwendet.\r\n// Wir könnten auch base64 verwenden, dabei hat man jedoch wieder Groß- und Kleinschreibung, was doof ist, sollte sich jemand die Mühe machen, alles in kleinbuchstaben abzutippen.\r\n// Wenn man das durch Convert.FromBase64String() ersetzt, muss man auf der Server-Seite evenfalls die funktion ersetzen.\r\nprivate static byte[] DecodeDataFromString(string value)\r\n{\r\n    // Hexadezimaen String zurück in Byte-Daten umwandeln\r\n    // macht das gleiche wie PHPs hex2bin; kehrt das bin2hex um.\r\n\r\n    if (value == null)\r\n        return new byte[0];\r\n\r\n    if ((value.Length & 1) != 0) // Länge der Daten ist nicht durch 2 teilbar -> kein gültiger hexadezimaler string\r\n        throw new FormatException();\r\n\r\n    if (string.IsNullOrWhiteSpace(value))\r\n        return new byte[0];\r\n\r\n    value = value.ToUpperInvariant();\r\n\r\n    byte[] ab = new byte[value.Length >> 1];\r\n    for (int i = 0; i < value.Length; i++)\r\n    {\r\n        int b = value[i];\r\n        b = (b - '0') + ((('9' - b) >> 31) & -7);\r\n        ab[i >> 1] |= (byte)(b << 4 * ((i & 1) ^ 1));\r\n    }\r\n    return ab;\r\n}\r\n```\r\n\r\nWie gesagt. Ich verwende hier ein Format, das ich von Sublime Text abgeschaut habe. Du kannst Dir auch ein eigenes ausdenken, das auf z. B. XML oder JSON basiert, um Dir das Auslesen zu vereinfachen.\r\n\r\n\r\n### 2. Standardisierung der übergebenen Daten in einheitliches Format\r\n\r\nDa wir nicht sicher ein können, dass unser Benutzer seinen Namen leicht abgeändert hat, müssen wir das Gane in ein Standard-Format bringen. Dies ist sinnvoll, da z. B. \"Erika Mustermann\" und \"erika Mustermann\" den gleichen Namen bezeichnen, aber ansich unterschiedliche Strings sind.\r\nHierfür habe ich folgende Funktion angelegt:\r\n```C#\r\nprivate static string GeneralizeDataString(string someString)\r\n{\r\n    return someString.StripWhiteSpace().ToUpperInvariant();\r\n}\r\n```\r\nDie StripWhiteSpace-Funktion ist als String-Extension wie folgt definiert:\r\n```C#\r\ninternal static class StringExtensions\r\n{\r\n    public static string StripWhiteSpace(this string value)\r\n    {\r\n        if (value == null)\r\n            return null;\r\n        if (value.Length == 0 || value.Trim().Length == 0)\r\n            return string.Empty;\r\n        var sb = new StringBuilder(value.Length);\r\n        for (int i = 0; i < value.Length; ++i)\r\n            if (!char.IsWhiteSpace(value[i]))\r\n                sb.Append(value[i]);\r\n        return sb.ToString();\r\n    }\r\n}\r\n```\r\n\r\nDiese funktion entfernt sämtlichen Whitespace aus dem String und konvertiert anschließend alle Buchstaben in Großbuchstaben.\r\nSo wird:\r\n`\"Erika Mustermann\"` zu `\"ErikaMustermann\"` zu `\"ERIKAMUSTERMANN\"`\r\n...und dementsprechend\r\n`\"erika Mustermann\"` zu `\"erikaMustermann\"` zu `\"ERIKAMUSTERMANN\"`\r\nAuch `\"eRikA musStermAnN\"` wird zu `\"ERIKAMUSTERMANN\"`.\r\nDadurch erreichen wir, dass die Lizenz weniger anfällig für Änderungen ist, die ein unerfahrener Benutzer eventuell vornehmen könnte (Änderung des String-Casings).\r\n\r\nDieser Schritt ist für alle Daten nötig, die für soetwas anfällig wären. In diesem Beispiel sind das aber keine weiteren.\r\n\r\n### 3. Validierung der Daten mittels überprüfung der RSA-Signatur\r\nNun kommt der eigentlich kryptografische Teil und auch die letzte Funktion der License-Klasse.\r\n\r\n```C#\r\nprivate bool ValidateLicense(byte[] signature)\r\n{\r\n    // Um die Lizenz auf Gültigkeit zu prüfen müssen alle zu prüfenden Parameter (Name, Typ) in einen Buffer gepackt werden\r\n    // Dies kann man wie folgt umsetzen:\r\n\r\n    // Standardisierung des Namens des Lizenznehmers\r\n    var licenseeGen = GeneralizeDataString(this._licensee); // \"ERIKAMUSTERMANN\"\r\n\r\n    // Zusammenfüren des Namens \"ERIKAMUSTERMANN\" mit dem Int-Wert des Lizenztyps (z. B. 2 für \"Commercial\").\r\n    var dataStr = licenseeGen + (int)this._type; //ERIKAMUSTERMANN2\r\n\r\n    // Erstellen eines Byte-Arrays aus dem zusammengefügten String\r\n    var dataBuffer = System.Text.Encoding.UTF8.GetBytes(dataStr);\r\n\r\n    // Crypto-Provider erstellen\r\n    using (var provider = new RSACryptoServiceProvider())\r\n    {\r\n        // Den Public Key festlegen\r\n        provider.FromXmlString(_publicKey);\r\n        provider.PersistKeyInCsp = false;\r\n\r\n        // Daten mit VerifyData überprüfen\r\n        // Übergeben wird hier der Datenpuffer, das Hashing-Verfahren für die Signatur und Signatur selbst\r\n        // In diesem Fall verwende ich SHA1\r\n        return provider.VerifyData(dataBuffer, new SHA1CryptoServiceProvider(), signature);\r\n        // Wenn die Daten gültig sind, sind die Lizenzdaten ebenfalls gültig. Wenn nicht, dann nicht.\r\n    }\r\n}\r\n```\r\nDas war's schon fast! Wir benötigen nun noch ein Schlüsselpaar. Dieses kann man z. B. mit OpenSSL erzeugen. Ich nehme hier jetzt mal ein Beispiel-Schlüsselpaar, welches Du nicht improduktiven Einsatz verwenden solltest!(!)\r\n\r\nMein Private Key in dem Fall:\r\n```XML\r\n<RSAKeyValue><Modulus>8CKn78RI6h7vNOPMeMCeRCHegEgG1nR+X84B8b3sOZF6hAjDXF80ag1Zw1T0E+NVHmbPB8aLgRPmQPA351ZR8D+BCHooDlGqstLLHiqTu9bbqRVPti46XBeju3Fbi47euO+omH0sq7LCuIZ5s1WBmTc9ejkkfc/0rk3fAYaIRuE=</Modulus><Exponent>AQAB</Exponent><P>/m1FEqol/KKhxOyGsK4GVuansBXhrAgpwMlYLT+vF0gy1jzYQDNNQXzeQFYH6gZY66RTYFl3JPNL8KXLyhwDLQ==</P><Q>8Z7DrGQsGhiLgg70j40/+AgfNKJB4SXY7FmyBmLPRiHkT2d3AyvzuNNf/hkHA2UMLQT4xewmkxK9MU2nDitzBQ==</Q><DP>uRVOSSyjo6u/WJzjwoVmMTNryymv2FC75vXRgmEwgxRPfxAWFGX9jmVC3LR432KsrwcEbDPI+4VNugsyO52zJQ==</DP><DQ>AJFY8FzD5cPNAB883+F7FwAd4qfG89p86gFD89PjnMyTlsQteWpvBi4o+ZXheFaScsCiPQTTCmFu5GDEVbowaQ==</DQ><InverseQ>7gQ8MGqjjrCAfOzrrC9ZuVdGRfEjUEdHMqiF+js7XNBvnT5lBznUOd+eta6CGo7S5hjU7D3CEzmVGQfxUsRZ1w==</InverseQ><D>6YSaERSs31dTwPghV+/gOFtDVzYzyAqi9iGMTHwnotfw70LiUAqZGuR+vO/5Jvn0RUsu2t3dvZkPWWkAxCtyIzALk8Brx1r8n76VHVWMzkZvOoqMa1/HdZCXM0TVlpnYVJjyUA8wzi4tzPIPv08lAGwYJzHcoMlFHkQ2npqflxE=</D></RSAKeyValue>\r\n```\r\n(Anmerkung: Beim XML-Format ist hier der Public Key mit dabei)\r\n\r\nDer dazugehörige Public Key:\r\n```XML\r\n<RSAKeyValue><Modulus>8CKn78RI6h7vNOPMeMCeRCHegEgG1nR+X84B8b3sOZF6hAjDXF80ag1Zw1T0E+NVHmbPB8aLgRPmQPA351ZR8D+BCHooDlGqstLLHiqTu9bbqRVPti46XBeju3Fbi47euO+omH0sq7LCuIZ5s1WBmTc9ejkkfc/0rk3fAYaIRuE=</Modulus><Exponent>AQAB</Exponent></RSAKeyValue>\r\n```\r\n\r\nIch habe beide Schlüssel jetzt im XML-Format. Wenn Du andere Formate bevorzugst, kannst Du diese auch verwenden. Ich nehme jetzt dieses, da dieses Format von Haus aus mit .NET kompatibel ist und die PHP-Library PHPSecLib es ebenfalls unterstützt.\r\n\r\nDer Private Key wird zum erstellen einer Lizenzdatei verwendet. Dieser darf niemals preisgegeben werden. Sobald jemand im Besitz dieses Schlüssels ist, kann derjenige sich so viele Lizenzen erstellen, wie er will!(!). Der Private Key darf auch keinesfalls irgendwo im Quelltext der Anwendung stehen, die an die Benutzer rausgeht!\r\n\r\n#### ...weiter im Text.\r\n\r\nDen Public Key fügen wir einfach oben als String-Wert der Konstante ein.\r\n\r\n```C#\r\nprivate const string _publicKey = @\"<RSAKeyValue><Modulus>8CKn78RI6h7vNOPMeMCeRCHegEgG1nR+X84B8b3sOZF6hAjDXF80ag1Zw1T0E+NVHmbPB8aLgRPmQPA351ZR8D+BCHooDlGqstLLHiqTu9bbqRVPti46XBeju3Fbi47euO+omH0sq7LCuIZ5s1WBmTc9ejkkfc/0rk3fAYaIRuE=</Modulus><Exponent>AQAB</Exponent></RSAKeyValue>\";\r\n```\r\n\r\nSoweit sind wir fertig! Der Client kann nun eine Lizenz parsen, sie in eine Klasse stecken und mittels RSA-Signatur validieren.\r\n\r\n### Lizenzen ausstellen\r\n\r\nUm Lizenzen auszustellen benötigen wir den Private Key. Bitte achte darauf, dass _niemand_ außer Dir Zugriff auf diesen Schlüssel haben darf.\r\n\r\nUm dies zu tun bietet sich ein Server an.\r\n\r\nMit PHP und der PHPSecLib könnte es wie folgt gehen. Die PHPSecLib bekommst du [hier](http://phpseclib.sourceforge.net). Falls du das GitHub-Repo geklont hast, ist es dort ebenfalls dabei.\r\n```PHP\r\n// Abbildung des Enums, das wir auch in der Client-Anwendung haben\r\nclass LicenseType\r\n{\r\n    const Personal = 1;\r\n    const Commercial = 2;\r\n    const OpenSource = 3;\r\n}\r\n```\r\n\r\n```PHP\r\n// Generierung von Lizenzen in einer separaten Klasse\r\nclass LicenseCreator\r\n{\r\n    // Niemals anderen Leuten zugänglich machen!\r\n    const privateKey = '<RSAKeyValue><Modulus>8CKn78RI6h7vNOPMeMCeRCHegEgG1nR+X84B8b3sOZF6hAjDXF80ag1Zw1T0E+NVHmbPB8aLgRPmQPA351ZR8D+BCHooDlGqstLLHiqTu9bbqRVPti46XBeju3Fbi47euO+omH0sq7LCuIZ5s1WBmTc9ejkkfc/0rk3fAYaIRuE=</Modulus><Exponent>AQAB</Exponent><P>/m1FEqol/KKhxOyGsK4GVuansBXhrAgpwMlYLT+vF0gy1jzYQDNNQXzeQFYH6gZY66RTYFl3JPNL8KXLyhwDLQ==</P><Q>8Z7DrGQsGhiLgg70j40/+AgfNKJB4SXY7FmyBmLPRiHkT2d3AyvzuNNf/hkHA2UMLQT4xewmkxK9MU2nDitzBQ==</Q><DP>uRVOSSyjo6u/WJzjwoVmMTNryymv2FC75vXRgmEwgxRPfxAWFGX9jmVC3LR432KsrwcEbDPI+4VNugsyO52zJQ==</DP><DQ>AJFY8FzD5cPNAB883+F7FwAd4qfG89p86gFD89PjnMyTlsQteWpvBi4o+ZXheFaScsCiPQTTCmFu5GDEVbowaQ==</DQ><InverseQ>7gQ8MGqjjrCAfOzrrC9ZuVdGRfEjUEdHMqiF+js7XNBvnT5lBznUOd+eta6CGo7S5hjU7D3CEzmVGQfxUsRZ1w==</InverseQ><D>6YSaERSs31dTwPghV+/gOFtDVzYzyAqi9iGMTHwnotfw70LiUAqZGuR+vO/5Jvn0RUsu2t3dvZkPWWkAxCtyIzALk8Brx1r8n76VHVWMzkZvOoqMa1/HdZCXM0TVlpnYVJjyUA8wzi4tzPIPv08lAGwYJzHcoMlFHkQ2npqflxE=</D></RSAKeyValue>';\r\n\r\n    public static function CreateLicense($licensee, $type)\r\n    {\r\n        // Gleiche Generalisierung wie am Client:\r\n        $licenseeGen = self::GeneralizeDataString($licensee);\r\n        $dataStr = $licenseeGen . (int)$type; // \"ERIKAMUSTERMANN2\"\r\n\r\n        $rsa = new Crypt_RSA(); // Neue RSA-Klasse erstellen\r\n\r\n        // Setzen der RSA-Optionen auf die, die auch am Client verwendet werden:\r\n        $rsa->setPrivateKeyFormat(CRYPT_RSA_PRIVATE_FORMAT_XML);\r\n        $rsa->setHash('SHA1');\r\n        $rsa->setSignatureMode(CRYPT_RSA_SIGNATURE_PKCS1);\r\n\r\n        // privaten Schlüssel laden\r\n        $rsa->loadKey(self::privateKey);\r\n\r\n        // Erstellen der Signatur\r\n        $signature = $rsa->sign($dataStr);\r\n\r\n        // Formatierte Lizenzdaten zurückgeben\r\n        return self::FormatLicense($licensee, $type, $signature);\r\n    }\r\n\r\n    private static function FormatLicense($licensee, $type, $signature)\r\n    {\r\n        // Binärdaten aus $signature in hexadezimal kodierten String umwandeln\r\n        $formattedSignature = self::EncodeDataToHexString($signature);\r\n\r\n        // Signatur in 29-Zeichen-Blöcke aufteilen (sieht schöner aus)\r\n        $formattedSignature = chunk_split($formattedSignature, 29);\r\n\r\n        $l = \"--------BEGIN LICENSE--------\\n\"; // Unser Anfangsblock\r\n        $l .= $licensee . \"\\n\"; // Der Name des Lizenznehmers\r\n        $l .= (int)$type . \"\\n\"; // Der Lizenztyp als Int\r\n        $l .= trim($formattedSignature) . \"\\n\"; // die in mehrere Zeilen aufgeteilte, kodierte Signatur\r\n        $l .= \"---------END LICENSE---------\"; // Ende der Lizenz\r\n\r\n        return $l;\r\n    }\r\n\r\n    private static function EncodeDataToHexString($data)\r\n    {\r\n        return strtoupper(bin2hex($data));\r\n    }\r\n\r\n    private static function GeneralizeDataString($someString)\r\n    {\r\n        // Gleiche Funktion wie am Client\r\n        return strtoupper(self::StripWhiteSpace($someString));\r\n    }\r\n\r\n    private static function StripWhiteSpace($someString)\r\n    {\r\n        // Gleiche Funktion wie am Client, nur mit RegEx\r\n        return preg_replace('/\\s+/', '', $someString);\r\n    }\r\n}\r\n```\r\n\r\n### Abschluss\r\n\r\nDas war's.\r\n\r\nAuf der Serverseite können wir nun mit Hilfe der LicenseCreator-Klasse eine Lizenz erstellen:\r\n```PHP\r\n$license = LicenseCreator::CreateLicense(\"Erika Mustermann\", LicenseType::Commercial);\r\n```\r\nHeraus kommt sowas:\r\n```\r\n--------BEGIN LICENSE--------\r\nErika Mustermann\r\n2\r\n0D0E9D62B80195C9C867CF451C312\r\n80593BFAEE80450BDD46A2CEAFFED\r\n6D378CD9408B328B05AC2C8D9A7AE\r\nD8B8B69D44DBF66EA0F814A800393\r\n7AD16197EF4DB28FDD27CFF58B1FC\r\n14DF3CD7912C41C2573BB0A0D59AD\r\n94BE0EFCD804D8A809875F13CAC70\r\n137F24E30478AE8DFD3B94025A38D\r\n80D636637F725887869ED77E\r\n---------END LICENSE---------\r\n```\r\n\r\nDieser String kann am Client validiert werden.\r\n```C#\r\nvar license = License.Parse(lizenzString);\r\nConsole.WriteLine(\"Lizenz gültig? \" + license.IsValid);\r\nif(license.IsValid)\r\n    Console.WriteLine(\"Lizenztyp: \" + license.Type);\r\n```\r\n\r\n#### Was es zu beachten gibt\r\n- Die Schlüssel sollten lang genug gewühlt werden (mindestens 2048 Bit sollten ausreichen)\r\n- Niemand anders sollte auf den Private Key Zugriff haben, da das komplette System sonst hinfällig ist.\r\n\r\n#### Erstellen von Schlüsseln\r\nDafür kannst Du OpenSSL oder andere Kryptosoftware verwenden. Wichtig ist nur, dass Du die Schlüssel später auch in der Anwendung verwenden kannst. Du kannst aber auch rein bei .NET bleiben. Ich mache es z. B. so:\r\n```C#\r\nconst int KeyLength = 2048;\r\nvar rsa = new RSACryptoServiceProvider(KeyLength);\r\nFile.WriteAllText(\"private_key.xml\", rsa.ToXmlString(true));\r\nFile.WriteAllText(\"public_key.xml\", rsa.ToXmlString(false));\r\n```\r\n\r\n#### Vorteile und Nachteile dieser Methode\r\n##### Vorteile\r\n- Keine Internetverbindung zum Validieren der Lizenz notwendig\r\n- Key-Generatoren sind so gut wie unmöglich, solange der Schlüssel lang genug gewählt wurde und der Private key privat bleibt\r\n- Geringe Fehleranfälligkeit, da man nicht auf Firewall-/Firmen-Umgebungen, die UAC oder ähnliches Rücksicht nehmen muss.\r\n\r\n##### Nachteile\r\n- Sehr einfach zu cracken\r\n\r\n#### Was noch gemacht werden muss\r\n- License.TryParse(), bei der keine Exception geworfen wird\r\n- Server-Beispiel mit Node.js\r\n\r\n#### \"Einfach zu Cracken\" vs \"Keygens unmöglich\":\r\nDas hört sich im ersten Moment recht widersprüchlich an, aber so ist es. Jemand könnte die Anwendung leicht cracken, indem an der entsprechenden Stelle einfach ein \"return true;\" eingefügt wird. Um dies zu tun, muss derjenige allerdings die Anwendung bearbeiten. Das hat den \"Nachteil\", dass wenn ein Update der Anwendung erscheint, er dies erneut machen muss. Das bringt einen zusätzlichen Aufwand mit sich.\r\n\r\n#### Meine Meinung zu dem Thema:\r\nIch finde, man sollte sein Programm nicht mit irgendwelchem \"unknackbaren\" Lizenzkram verwurschteln, was es am Ende nur fehleranfälliger und unbenutzbarer macht. Wirklich viel mehr geschützt ist es dadurch auch nicht.\r\nGenerell sollte man IMO die Zeit lieber in die Funktionalität des Programms statt in ein komplexes Lizenzsystem stecken.\r\nDas hier gezeigte System ähnelt stark dem, welches u. A. bei Sublime Text zum Einsatz kommt.\r\nIch finde diese Herangehensweise noch vertretbar, da sie recht simpel gehalten ist und trotzdem noch eine (kleine) Hürde bietet.\r\nDieser Beitrag soll nicht bedeuten, dass man in allen Programmen so ein System einbauen soll. Nein, ganz und gar nicht. Ich bin ein freund von freier und offener Software und will lediglich zeigen, wie man diese Problemstellung angehen kann.\r\nAußerdem habe ich auf meiner Arbeit oft mit schlecht programmierter Software zu tun, die häufig wegen ignorant implementiertem Lizenzkram die Funktion verweigert.\r\nBeispiel?\r\n[Hier](https://stackoverflow.com/q/25486319/785210) will Jemand irgendwelchen Lizenzkram mit Festplattenseriennummern hinfriemeln. Aus irgendeinem Grund funktioniert das aber nicht immer, weshalb seine Software wahrscheinlich unrechtmäßig die Funktion verweigern wird. Sowas nervt absolut jeden Sysadmin und Anwender. Lasst sowas bitte.\r\n\r\n#### Disclaimer\r\nDas Übliche:\r\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\r\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n","google":"UA-62961705-3","note":"Don't delete this file! It's used internally to help with page regeneration."}